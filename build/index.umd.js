!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).fief={})}(this,(function(e){"use strict";function t(e,t,r,n){return new(r||(r=Promise))((function(i,o){function s(e){try{c(n.next(e))}catch(e){o(e)}}function a(e){try{c(n.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,a)}c((n=n.apply(e,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;class r extends Error{}class n extends r{}const i=e=>btoa(String.fromCharCode(...new Uint8Array(e))).replace(/=/g,"").replace(/[+/]/g,(e=>"+"===e?"-":"_"));class o{constructor(){if("undefined"!=typeof window&&window.crypto&&(this.crypto=window.crypto),"undefined"!=typeof self&&self.crypto&&(this.crypto=self.crypto),"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime&&(this.crypto=globalThis.crypto),void 0===this.crypto)throw new n("Cannot find the Crypto module. Are you sure you are in a browser environment?")}getValidationHash(e){return t(this,void 0,void 0,(function*(){const t=(new TextEncoder).encode(e),r=yield this.crypto.subtle.digest("SHA-256",t),n=r.slice(0,r.byteLength/2);return i(n)}))}isValidHash(e,r){return t(this,void 0,void 0,(function*(){return(yield this.getValidationHash(e))===r}))}generateCodeVerifier(){return t(this,void 0,void 0,(function*(){const e=new Uint8Array(96);return this.crypto.getRandomValues(e),i(e)}))}getCodeChallenge(e,n){return t(this,void 0,void 0,(function*(){if("plain"===n)return e;if("S256"===n){const t=(new TextEncoder).encode(e),r=yield this.crypto.subtle.digest("SHA-256",t);return i(r)}throw new r(`Invalid method "${n}". Allowed methods are: plain, S256`)}))}}const s=()=>new o;var a=Object.freeze({__proto__:null,CryptoHelperError:r,getCrypto:s});class c{constructor(){this.storage=window.sessionStorage}getUserinfo(){const e=this.storage.getItem(c.USERINFO_STORAGE_KEY);return e?JSON.parse(e):null}setUserinfo(e){this.storage.setItem(c.USERINFO_STORAGE_KEY,JSON.stringify(e))}clearUserinfo(){this.storage.removeItem(c.USERINFO_STORAGE_KEY)}getTokenInfo(){const e=this.storage.getItem(c.TOKEN_INFO_STORAGE_KEY);return e?JSON.parse(e):null}setTokenInfo(e){this.storage.setItem(c.TOKEN_INFO_STORAGE_KEY,JSON.stringify(e))}clearTokeninfo(){this.storage.removeItem(c.TOKEN_INFO_STORAGE_KEY)}getCodeVerifier(){const e=this.storage.getItem(c.CODE_VERIFIER_STORAGE_KEY);return e||null}setCodeVerifier(e){this.storage.setItem(c.CODE_VERIFIER_STORAGE_KEY,e)}clearCodeVerifier(){this.storage.removeItem(c.CODE_VERIFIER_STORAGE_KEY)}}c.USERINFO_STORAGE_KEY="fief-userinfo",c.TOKEN_INFO_STORAGE_KEY="fief-tokeninfo",c.CODE_VERIFIER_STORAGE_KEY="fief-codeverifier";class d extends Error{}class h extends d{constructor(e,t=null){super(),this.error=e,this.description=t}}class l extends d{}var u=Object.freeze({__proto__:null,FiefAuth:class{constructor(e,t){this.client=e,this.storage=void 0!==t?t:new c,this.crypto=s(),this.pendingAuthCallbacks=new Set}isAuthenticated(){return null!==this.storage.getTokenInfo()}getUserinfo(){return this.storage.getUserinfo()}getTokenInfo(){return this.storage.getTokenInfo()}redirectToLogin(e,r){return t(this,void 0,void 0,(function*(){const t=yield this.crypto.generateCodeVerifier(),n=yield this.crypto.getCodeChallenge(t,"S256");this.storage.setCodeVerifier(t);const i=yield this.client.getAuthURL(Object.assign(Object.assign(Object.assign({redirectURI:e,scope:(null==r?void 0:r.scope)||["openid"],codeChallenge:n,codeChallengeMethod:"S256"},(null==r?void 0:r.state)?{state:r.state}:{}),(null==r?void 0:r.state)?{lang:r.lang}:{}),(null==r?void 0:r.extrasParams)?{extrasParams:r.extrasParams}:{}));window.location.href=i}))}authCallback(e){return t(this,void 0,void 0,(function*(){const t=new URLSearchParams(window.location.search),r=t.get("error"),n=t.get("error_description"),i=t.get("code");if(null!==r)throw new h(r,n);if(null===i)throw new h("missing_code");if(this.pendingAuthCallbacks.has(i))return;const o=this.storage.getCodeVerifier();this.storage.clearCodeVerifier(),this.pendingAuthCallbacks.add(i);const[s,a]=yield this.client.authCallback(i,e,o||void 0);this.pendingAuthCallbacks.delete(i),this.storage.setTokenInfo(s),this.storage.setUserinfo(a)}))}refreshUserinfo(){return t(this,void 0,void 0,(function*(){const e=this.getTokenInfo();if(null===e)throw new l;const t=yield this.client.userinfo(e.access_token);return this.storage.setUserinfo(t),t}))}logout(e){return t(this,void 0,void 0,(function*(){this.storage.clearUserinfo(),this.storage.clearTokeninfo();const t=yield this.client.getLogoutURL({redirectURI:e});window.location.href=t}))}},FiefAuthAuthorizeError:h,FiefAuthError:d,FiefAuthNotAuthenticatedError:l}),f=crypto;const p=e=>e instanceof CryptoKey,y=async(e,t)=>{const r=`SHA-${e.slice(-3)}`;return new Uint8Array(await f.subtle.digest(r,t))},w=new TextEncoder,g=new TextDecoder,E=2**32;function m(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}function A(e,t,r){if(t<0||t>=E)throw new RangeError(`value must be >= 0 and <= ${E-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function S(e){const t=new Uint8Array(4);return A(t,e),t}function b(e){return m(S(e.length),e)}const v=e=>{let t=e;t instanceof Uint8Array&&(t=g.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class C extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class R extends C{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,t,r="unspecified",n="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n,this.payload=t}}class O extends C{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,t,r="unspecified",n="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n,this.payload=t}}class _ extends C{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class k extends C{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class T extends C{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class I extends C{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class P extends C{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class K extends C{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class W extends C{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class H extends C{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class J extends C{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}class j extends C{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var U=f.getRandomValues.bind(f);const D=(e,t)=>{if(t.length<<3!==function(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new k(`Unsupported JWE Algorithm: ${e}`)}}(e))throw new I("Invalid Initialization Vector length")},x=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new I(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)};function $(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function N(e,t){return e.name===t}function L(e){return parseInt(e.name.slice(4),10)}function M(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function F(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!N(e.algorithm,"HMAC"))throw $("HMAC");const r=parseInt(t.slice(2),10);if(L(e.algorithm.hash)!==r)throw $(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!N(e.algorithm,"RSASSA-PKCS1-v1_5"))throw $("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(L(e.algorithm.hash)!==r)throw $(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!N(e.algorithm,"RSA-PSS"))throw $("RSA-PSS");const r=parseInt(t.slice(2),10);if(L(e.algorithm.hash)!==r)throw $(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw $("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!N(e.algorithm,"ECDSA"))throw $("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw $(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}M(e,r)}function G(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!N(e.algorithm,"AES-GCM"))throw $("AES-GCM");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw $(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!N(e.algorithm,"AES-KW"))throw $("AES-KW");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw $(r,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw $("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!N(e.algorithm,"PBKDF2"))throw $("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!N(e.algorithm,"RSA-OAEP"))throw $("RSA-OAEP");const r=parseInt(t.slice(9),10)||1;if(L(e.algorithm.hash)!==r)throw $(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}M(e,r)}function B(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var V=(e,...t)=>B("Key must be ",e,...t);function q(e,t,...r){return B(`Key for the ${e} algorithm must be `,t,...r)}var z=e=>p(e);const Y=["CryptoKey"];async function X(e,t,r,n,i,o){if(!(t instanceof Uint8Array))throw new TypeError(V(t,"Uint8Array"));const s=parseInt(e.slice(1,4),10),a=await f.subtle.importKey("raw",t.subarray(s>>3),"AES-CBC",!1,["decrypt"]),c=await f.subtle.importKey("raw",t.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),d=m(o,n,r,function(e){const t=Math.floor(e/E),r=e%E,n=new Uint8Array(8);return A(n,t,0),A(n,r,4),n}(o.length<<3)),h=new Uint8Array((await f.subtle.sign("HMAC",c,d)).slice(0,s>>3));let l,u;try{l=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,i=-1;for(;++i<r;)n|=e[i]^t[i];return 0===n})(i,h)}catch{}if(!l)throw new T;try{u=new Uint8Array(await f.subtle.decrypt({iv:n,name:"AES-CBC"},a,r))}catch{}if(!u)throw new T;return u}const Z=async(e,t,r,n,i,o)=>{if(!(p(t)||t instanceof Uint8Array))throw new TypeError(V(t,...Y,"Uint8Array"));if(!n)throw new I("JWE Initialization Vector missing");if(!i)throw new I("JWE Authentication Tag missing");switch(D(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&x(t,parseInt(e.slice(-3),10)),X(e,t,r,n,i,o);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&x(t,parseInt(e.slice(1,4),10)),async function(e,t,r,n,i,o){let s;t instanceof Uint8Array?s=await f.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(G(t,e,"decrypt"),s=t);try{return new Uint8Array(await f.subtle.decrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},s,m(r,i)))}catch{throw new T}}(e,t,r,n,i,o);default:throw new k("Unsupported JWE Content Encryption Algorithm")}},Q=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function ee(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const te=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];const re=async(e,t,r)=>{const n=await function(e,t,r){if(p(e))return G(e,t,r),e;if(e instanceof Uint8Array)return f.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(V(e,...Y,"Uint8Array"))}(t,e,"unwrapKey");!function(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}(n,e);const i=await f.subtle.unwrapKey("raw",r,n,"AES-KW",...te);return new Uint8Array(await f.subtle.exportKey("raw",i))};async function ne(e,t,r,n,i=new Uint8Array(0),o=new Uint8Array(0)){if(!p(e))throw new TypeError(V(e,...Y));if(G(e,"ECDH"),!p(t))throw new TypeError(V(t,...Y));G(t,"ECDH","deriveBits");const s=m(b(w.encode(r)),b(i),b(o),S(n));let a;a="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,r){const n=Math.ceil((t>>3)/32),i=new Uint8Array(32*n);for(let t=0;t<n;t++){const n=new Uint8Array(4+e.length+r.length);n.set(S(t+1)),n.set(e,4),n.set(r,4+e.length),i.set(await y("sha256",n),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await f.subtle.deriveBits({name:e.algorithm.name,public:e},t,a)),n,s)}async function ie(e,t,r,n){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new I("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,t){return m(w.encode(e),new Uint8Array([0]),t)}(t,e),o=parseInt(t.slice(13,16),10),s={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:i},a={length:o,name:"AES-KW"},c=await function(e,t){if(e instanceof Uint8Array)return f.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(p(e))return G(e,t,"deriveBits","deriveKey"),e;throw new TypeError(V(e,...Y,"Uint8Array"))}(n,t);if(c.usages.includes("deriveBits"))return new Uint8Array(await f.subtle.deriveBits(s,c,o));if(c.usages.includes("deriveKey"))return f.subtle.deriveKey(s,c,a,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const oe=async(e,t,r,n,i)=>{const o=await ie(i,e,n,t);return re(e.slice(-6),o,r)};function se(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new k(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var ae=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const ce=async(e,t,r)=>{if(!p(t))throw new TypeError(V(t,...Y));if(G(t,e,"decrypt","unwrapKey"),ae(e,t),t.usages.includes("decrypt"))return new Uint8Array(await f.subtle.decrypt(se(e),t,r));if(t.usages.includes("unwrapKey")){const n=await f.subtle.unwrapKey("raw",r,t,se(e),...te);return new Uint8Array(await f.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function de(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new k(`Unsupported JWE Algorithm: ${e}`)}}var he=e=>U(new Uint8Array(de(e)>>3));var le=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=function(e){let t,r;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new k('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new k('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new k('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new k('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),n=[t,e.ext??!1,e.key_ops??r],i={...e};return delete i.alg,delete i.use,f.subtle.importKey("jwk",i,...n)};async function ue(e,t){if(!ee(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return v(e.k);case"RSA":if(void 0!==e.oth)throw new k('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return le({...e,alg:t});default:throw new k('Unsupported "kty" (Key Type) Parameter value')}}const fe=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!z(t))throw new TypeError(q(e,t,...Y,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${Y.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!z(t))throw new TypeError(q(e,t,...Y));if("secret"===t.type)throw new TypeError(`${Y.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${Y.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${Y.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${Y.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${Y.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,r)};async function pe(e,t,r,n,i){switch(fe(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new I("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new I("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ee(n.epk))throw new I('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!function(e){if(!p(e))throw new TypeError(V(e,...Y));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}(t))throw new k("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await ue(n.epk,e);let o,s;if(void 0!==n.apu){if("string"!=typeof n.apu)throw new I('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{o=v(n.apu)}catch{throw new I("Failed to base64url decode the apu")}}if(void 0!==n.apv){if("string"!=typeof n.apv)throw new I('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{s=v(n.apv)}catch{throw new I("Failed to base64url decode the apv")}}const a=await ne(i,t,"ECDH-ES"===e?n.enc:e,"ECDH-ES"===e?de(n.enc):parseInt(e.slice(-5,-2),10),o,s);if("ECDH-ES"===e)return a;if(void 0===r)throw new I("JWE Encrypted Key missing");return re(e.slice(-6),a,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new I("JWE Encrypted Key missing");return ce(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===r)throw new I("JWE Encrypted Key missing");if("number"!=typeof n.p2c)throw new I('JOSE Header "p2c" (PBES2 Count) missing or invalid');const o=i?.maxPBES2Count||1e4;if(n.p2c>o)throw new I('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof n.p2s)throw new I('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let s;try{s=v(n.p2s)}catch{throw new I("Failed to base64url decode the p2s")}return oe(e,t,r,n.p2c,s)}case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new I("JWE Encrypted Key missing");return re(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===r)throw new I("JWE Encrypted Key missing");if("string"!=typeof n.iv)throw new I('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof n.tag)throw new I('JOSE Header "tag" (Authentication Tag) missing or invalid');let i,o;try{i=v(n.iv)}catch{throw new I("Failed to base64url decode the iv")}try{o=v(n.tag)}catch{throw new I("Failed to base64url decode the tag")}return async function(e,t,r,n,i){const o=e.slice(0,7);return Z(o,t,r,n,i,new Uint8Array(0))}(e,t,r,i,o)}default:throw new k('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function ye(e,t,r,n,i){if(void 0!==i.crit&&void 0===n?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!o.has(t))throw new k(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}const we=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function ge(e,t,r){if(e instanceof Uint8Array&&(e=g.decode(e)),"string"!=typeof e)throw new I("Compact JWE must be a string or Uint8Array");const{0:n,1:i,2:o,3:s,4:a,length:c}=e.split(".");if(5!==c)throw new I("Invalid Compact JWE");const d=await async function(e,t,r){if(!ee(e))throw new I("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new I("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new I("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new I("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new I("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new I("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new I("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new I("JWE AAD incorrect type");if(void 0!==e.header&&!ee(e.header))throw new I("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!ee(e.unprotected))throw new I("JWE Per-Recipient Unprotected Header incorrect type");let n;if(e.protected)try{const t=v(e.protected);n=JSON.parse(g.decode(t))}catch{throw new I("JWE Protected Header is invalid")}if(!Q(n,e.header,e.unprotected))throw new I("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const i={...n,...e.header,...e.unprotected};if(ye(I,new Map,r?.crit,n,i),void 0!==i.zip)throw new k('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:o,enc:s}=i;if("string"!=typeof o||!o)throw new I("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof s||!s)throw new I("missing JWE Encryption Algorithm (enc) in JWE Header");const a=r&&we("keyManagementAlgorithms",r.keyManagementAlgorithms),c=r&&we("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(a&&!a.has(o)||!a&&o.startsWith("PBES2"))throw new _('"alg" (Algorithm) Header Parameter value not allowed');if(c&&!c.has(s))throw new _('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(void 0!==e.encrypted_key)try{d=v(e.encrypted_key)}catch{throw new I("Failed to base64url decode the encrypted_key")}let h,l,u,f=!1;"function"==typeof t&&(t=await t(n,e),f=!0);try{h=await pe(o,t,d,i,r)}catch(e){if(e instanceof TypeError||e instanceof I||e instanceof k)throw e;h=he(s)}if(void 0!==e.iv)try{l=v(e.iv)}catch{throw new I("Failed to base64url decode the iv")}if(void 0!==e.tag)try{u=v(e.tag)}catch{throw new I("Failed to base64url decode the tag")}const p=w.encode(e.protected??"");let y,E;y=void 0!==e.aad?m(p,w.encode("."),w.encode(e.aad)):p;try{E=v(e.ciphertext)}catch{throw new I("Failed to base64url decode the ciphertext")}const A={plaintext:await Z(s,h,E,l,u,y)};if(void 0!==e.protected&&(A.protectedHeader=n),void 0!==e.aad)try{A.additionalAuthenticatedData=v(e.aad)}catch{throw new I("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(A.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(A.unprotectedHeader=e.header),f?{...A,key:t}:A}({ciphertext:s,iv:o||void 0,protected:n,tag:a||void 0,encrypted_key:i||void 0},t,r),h={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return"function"==typeof t?{...h,key:d.key}:h}const Ee=async(e,t,r,n)=>{const i=await function(e,t,r){if(p(t))return F(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(V(t,...Y));return f.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(V(t,...Y,"Uint8Array"))}(e,t,"verify");ae(e,i);const o=function(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new k(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e,i.algorithm);try{return await f.subtle.verify(o,i,r,n)}catch{return!1}};async function me(e,t,r){if(e instanceof Uint8Array&&(e=g.decode(e)),"string"!=typeof e)throw new P("Compact JWS must be a string or Uint8Array");const{0:n,1:i,2:o,length:s}=e.split(".");if(3!==s)throw new P("Invalid Compact JWS");const a=await async function(e,t,r){if(!ee(e))throw new P("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new P('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new P("JWS Protected Header incorrect type");if(void 0===e.payload)throw new P("JWS Payload missing");if("string"!=typeof e.signature)throw new P("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ee(e.header))throw new P("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const t=v(e.protected);n=JSON.parse(g.decode(t))}catch{throw new P("JWS Protected Header is invalid")}if(!Q(n,e.header))throw new P("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...n,...e.header};let o=!0;if(ye(P,new Map([["b64",!0]]),r?.crit,n,i).has("b64")&&(o=n.b64,"boolean"!=typeof o))throw new P('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=i;if("string"!=typeof s||!s)throw new P('JWS "alg" (Algorithm) Header Parameter missing or invalid');const a=r&&we("algorithms",r.algorithms);if(a&&!a.has(s))throw new _('"alg" (Algorithm) Header Parameter value not allowed');if(o){if("string"!=typeof e.payload)throw new P("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new P("JWS Payload must be a string or an Uint8Array instance");let c=!1;"function"==typeof t&&(t=await t(n,e),c=!0),fe(s,t,"verify");const d=m(w.encode(e.protected??""),w.encode("."),"string"==typeof e.payload?w.encode(e.payload):e.payload);let h,l;try{h=v(e.signature)}catch{throw new P("Failed to base64url decode the signature")}if(!await Ee(s,t,h,d))throw new j;if(o)try{l=v(e.payload)}catch{throw new P("Failed to base64url decode the payload")}else l="string"==typeof e.payload?w.encode(e.payload):e.payload;const u={payload:l};return void 0!==e.protected&&(u.protectedHeader=n),void 0!==e.header&&(u.unprotectedHeader=e.header),c?{...u,key:t}:u}({payload:i,protected:n,signature:o},t,r),c={payload:a.payload,protectedHeader:a.protectedHeader};return"function"==typeof t?{...c,key:a.key}:c}const Ae=86400,Se=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;var be=e=>{const t=Se.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]);let n;switch(t[3].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":n=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":n=Math.round(60*r);break;case"hour":case"hours":case"hr":case"hrs":case"h":n=Math.round(3600*r);break;case"day":case"days":case"d":n=Math.round(r*Ae);break;case"week":case"weeks":case"w":n=Math.round(604800*r);break;default:n=Math.round(31557600*r)}return"-"===t[1]||"ago"===t[4]?-n:n};const ve=e=>e.toLowerCase().replace(/^application\//,"");var Ce=(e,t,r={})=>{let n;try{n=JSON.parse(g.decode(t))}catch{}if(!ee(n))throw new K("JWT Claims Set must be a top-level JSON object");const{typ:i}=r;if(i&&("string"!=typeof e.typ||ve(e.typ)!==ve(i)))throw new R('unexpected "typ" JWT header value',n,"typ","check_failed");const{requiredClaims:o=[],issuer:s,subject:a,audience:c,maxTokenAge:d}=r,h=[...o];void 0!==d&&h.push("iat"),void 0!==c&&h.push("aud"),void 0!==a&&h.push("sub"),void 0!==s&&h.push("iss");for(const e of new Set(h.reverse()))if(!(e in n))throw new R(`missing required "${e}" claim`,n,e,"missing");if(s&&!(Array.isArray(s)?s:[s]).includes(n.iss))throw new R('unexpected "iss" claim value',n,"iss","check_failed");if(a&&n.sub!==a)throw new R('unexpected "sub" claim value',n,"sub","check_failed");if(c&&(l=n.aud,u="string"==typeof c?[c]:c,!("string"==typeof l?u.includes(l):Array.isArray(l)&&u.some(Set.prototype.has.bind(new Set(l))))))throw new R('unexpected "aud" claim value',n,"aud","check_failed");var l,u;let f;switch(typeof r.clockTolerance){case"string":f=be(r.clockTolerance);break;case"number":f=r.clockTolerance;break;case"undefined":f=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:p}=r,y=(w=p||new Date,Math.floor(w.getTime()/1e3));var w;if((void 0!==n.iat||d)&&"number"!=typeof n.iat)throw new R('"iat" claim must be a number',n,"iat","invalid");if(void 0!==n.nbf){if("number"!=typeof n.nbf)throw new R('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>y+f)throw new R('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(void 0!==n.exp){if("number"!=typeof n.exp)throw new R('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=y-f)throw new O('"exp" claim timestamp check failed',n,"exp","check_failed")}if(d){const e=y-n.iat;if(e-f>("number"==typeof d?d:be(d)))throw new O('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(e<0-f)throw new R('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n};async function Re(e,t,r){const n=await me(e,t,r);if(n.protectedHeader.crit?.includes("b64")&&!1===n.protectedHeader.b64)throw new K("JWTs MUST NOT use unencoded payload");const i={payload:Ce(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return"function"==typeof t?{...i,key:n.key}:i}function Oe(e){return ee(e)}function _e(e){return"function"==typeof structuredClone?structuredClone(e):JSON.parse(JSON.stringify(e))}class ke{constructor(e){if(this._cached=new WeakMap,!function(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(Oe)}(e))throw new W("JSON Web Key Set malformed");this._jwks=_e(e)}async getKey(e,t){const{alg:r,kid:n}={...e,...t?.header},i=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new k('Unsupported "alg" value for a JSON Web Key Set')}}(r),o=this._jwks.keys.filter((e=>{let t=i===e.kty;if(t&&"string"==typeof n&&(t=n===e.kid),t&&"string"==typeof e.alg&&(t=r===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t&&"EdDSA"===r&&(t="Ed25519"===e.crv||"Ed448"===e.crv),t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv}return t})),{0:s,length:a}=o;if(0===a)throw new H;if(1!==a){const e=new J,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(const e of o)try{yield await Te(t,e,r)}catch{}},e}return Te(this._cached,s,r)}}async function Te(e,t,r){const n=e.get(t)||e.set(t,{}).get(t);if(void 0===n[r]){const e=await ue({...t,ext:!0},r);if(e instanceof Uint8Array||"public"!==e.type)throw new W("JSON Web Key Set members must be public keys");n[r]=e}return n[r]}function Ie(e){const t=new ke(e),r=async(e,r)=>t.getKey(e,r);return Object.defineProperties(r,{jwks:{value:()=>_e(t._jwks),enumerable:!0,configurable:!1,writable:!1}}),r}class Pe extends Error{}const Ke=e=>{const t=[];return Object.keys(e).forEach((r=>{Object.prototype.hasOwnProperty.call(e,r)&&t.push(`${encodeURIComponent(r)}=${encodeURIComponent(e[r])}`)})),t.join("&")};var We;e.FiefACR=void 0,(We=e.FiefACR||(e.FiefACR={})).LEVEL_ZERO="0",We.LEVEL_ONE="1";const He=[e.FiefACR.LEVEL_ZERO,e.FiefACR.LEVEL_ONE];class Je extends Error{}class je extends Je{constructor(e,t){super(`[${e}] - ${t}`),this.status=e,this.detail=t}}class Ue extends Je{}class De extends Je{}class xe extends Je{}class $e extends Je{}class Ne extends Je{}class Le extends Je{}class Me{constructor(e){this.baseURL=e.baseURL,this.clientId=e.clientId,this.clientSecret=e.clientSecret,void 0!==e.encryptionKey&&ue(JSON.parse(e.encryptionKey),"RSA-OAEP-256").then((e=>{this.encryptionKey=e})),this.fetch=(()=>{if("undefined"!=typeof window&&window.fetch)return window.fetch.bind(window);if("undefined"!=typeof self&&self.fetch)return self.fetch.bind(self);if("undefined"!=typeof globalThis&&globalThis.fetch)return globalThis.fetch.bind(globalThis);throw new Pe("Cannot find a fetch implementation for your environment")})(),this.requestInit=e.requestInit,this.crypto=s()}getAuthURL(e){return t(this,void 0,void 0,(function*(){const t=yield this.getOpenIDConfiguration(),{redirectURI:r,state:n,scope:i,codeChallenge:o,codeChallengeMethod:s,lang:a,extrasParams:c}=e,d=new URLSearchParams(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({response_type:"code",client_id:this.clientId,redirect_uri:r},n?{state:n}:{}),o?{code_challenge:o}:{}),s?{code_challenge_method:s}:{}),n?{state:n}:{}),i?{scope:i.join(" ")}:{}),a?{lang:a}:{}),c?Object.assign({},c):{}));return`${t.authorization_endpoint}?${d.toString()}`}))}authCallback(e,r,n,i){return t(this,void 0,void 0,(function*(){const t=yield this.getOpenIDConfiguration(),o=Ke(Object.assign(Object.assign({grant_type:"authorization_code",client_id:this.clientId,code:e,redirect_uri:r},this.clientSecret?{client_secret:this.clientSecret}:{}),n?{code_verifier:n}:{})),s=yield this.fetch(t.token_endpoint,Object.assign(Object.assign({},i||{}),{method:"POST",body:o,headers:Object.assign(Object.assign({},i&&i.headers?i.headers:{}),{"Content-Type":"application/x-www-form-urlencoded"})}));yield Me.handleRequestError(s);const a=yield s.json();return[a,yield this.decodeIDToken({idToken:a.id_token,jwks:yield this.getJWKS(),code:e,accessToken:a.access_token})]}))}authRefreshToken(e,r,n){return t(this,void 0,void 0,(function*(){const t=yield this.getOpenIDConfiguration(),i=Ke(Object.assign({grant_type:"refresh_token",client_id:this.clientId,refresh_token:e},r?{scope:r.join(" ")}:{})),o=yield this.fetch(t.token_endpoint,Object.assign(Object.assign({},n||{}),{method:"POST",body:i,headers:Object.assign(Object.assign({},n&&n.headers?n.headers:{}),{"Content-Type":"application/x-www-form-urlencoded"})}));yield Me.handleRequestError(o);const s=yield o.json();return[s,yield this.decodeIDToken({idToken:s.id_token,jwks:yield this.getJWKS(),accessToken:s.access_token})]}))}validateAccessToken(r,n,i,o){return t(this,void 0,void 0,(function*(){const t=Ie(yield this.getJWKS());try{const{payload:c}=yield Re(r,t),d=c.scope;if(void 0===d)throw new Ue;const h=d.split(" ");n&&n.forEach((e=>{if(!h.some((t=>t===e)))throw new xe}));const l=c.acr;if(void 0===l||!Object.values(e.FiefACR).includes(l))throw new Ue;if(i&&(s=l,a=i,He.findIndex((e=>e===s))-He.findIndex((e=>e===a))<0))throw new $e;const u=c.permissions;if(void 0===u)throw new Ue;return o&&o.forEach((e=>{if(!u.some((t=>t===e)))throw new Ne})),{id:c.sub,scope:h,acr:l,permissions:u,access_token:r}}catch(e){if(e instanceof O)throw new De;if(e instanceof C)throw new Ue;throw e}var s,a}))}userinfo(e,r){return t(this,void 0,void 0,(function*(){const t=yield this.getOpenIDConfiguration(),n=yield this.fetch(t.userinfo_endpoint,Object.assign(Object.assign({},r||{}),{method:"GET",headers:Object.assign(Object.assign({},r&&r.headers?r.headers:{}),{Authorization:`Bearer ${e}`})}));yield Me.handleRequestError(n);return yield n.json()}))}updateProfile(e,r,n){return t(this,void 0,void 0,(function*(){const t=`${this.baseURL}/api/profile`,i=yield this.fetch(t,Object.assign(Object.assign({},n||{}),{method:"PATCH",body:JSON.stringify(r),headers:Object.assign(Object.assign({},n&&n.headers?n.headers:{}),{"Content-Type":"application/json",Authorization:`Bearer ${e}`})}));yield Me.handleRequestError(i);return yield i.json()}))}changePassword(e,r,n){return t(this,void 0,void 0,(function*(){const t=`${this.baseURL}/api/password`,i=yield this.fetch(t,Object.assign(Object.assign({},n||{}),{method:"PATCH",body:JSON.stringify({password:r}),headers:Object.assign(Object.assign({},n&&n.headers?n.headers:{}),{"Content-Type":"application/json",Authorization:`Bearer ${e}`})}));yield Me.handleRequestError(i);return yield i.json()}))}emailChange(e,r,n){return t(this,void 0,void 0,(function*(){const t=`${this.baseURL}/api/email/change`,i=yield this.fetch(t,Object.assign(Object.assign({},n||{}),{method:"PATCH",body:JSON.stringify({email:r}),headers:Object.assign(Object.assign({},n&&n.headers?n.headers:{}),{"Content-Type":"application/json",Authorization:`Bearer ${e}`})}));yield Me.handleRequestError(i);return yield i.json()}))}emailVerify(e,r,n){return t(this,void 0,void 0,(function*(){const t=`${this.baseURL}/api/email/verify`,i=yield this.fetch(t,Object.assign(Object.assign({},n||{}),{method:"POST",body:JSON.stringify({code:r}),headers:Object.assign(Object.assign({},n&&n.headers?n.headers:{}),{"Content-Type":"application/json",Authorization:`Bearer ${e}`})}));yield Me.handleRequestError(i);return yield i.json()}))}getLogoutURL(e){return t(this,void 0,void 0,(function*(){const t=new URLSearchParams({redirect_uri:e.redirectURI});return`${this.baseURL}/logout?${t.toString()}`}))}getOpenIDConfiguration(){return t(this,void 0,void 0,(function*(){if(void 0!==this.openIDConfiguration)return this.openIDConfiguration;const e=yield this.fetch(`${this.baseURL}/.well-known/openid-configuration`,Object.assign(Object.assign({},this.requestInit||{}),{method:"GET"}));yield Me.handleRequestError(e);const t=e.json();return this.openIDConfiguration=t,t}))}getJWKS(){return t(this,void 0,void 0,(function*(){if(void 0!==this.jwks)return this.jwks;const e=yield this.getOpenIDConfiguration(),t=yield this.fetch(e.jwks_uri,Object.assign(Object.assign({},this.requestInit||{}),{method:"GET"}));yield Me.handleRequestError(t);const r=yield t.json();return this.jwks=r,r}))}decodeIDToken(e){return t(this,void 0,void 0,(function*(){const{idToken:t,jwks:r,code:n,accessToken:i}=e,o=Ie(r);try{let e=t;if(void 0!==this.encryptionKey){const{plaintext:r}=yield ge(t,this.encryptionKey);e=r}const{payload:r}=yield Re(e,o);if(!(void 0===r.c_hash||n&&(yield this.crypto.isValidHash(n,r.c_hash))))throw new Le;if(!(void 0===r.at_hash||i&&(yield this.crypto.isValidHash(i,r.at_hash))))throw new Le;return r}catch(e){if(e instanceof C)throw new Le;throw e}}))}static handleRequestError(e){return t(this,void 0,void 0,(function*(){if(e.status<200||e.status>299){const t=yield e.text();throw new je(e.status,t)}}))}}e.Fief=Me,e.FiefAccessTokenACRTooLow=$e,e.FiefAccessTokenExpired=De,e.FiefAccessTokenInvalid=Ue,e.FiefAccessTokenMissingPermission=Ne,e.FiefAccessTokenMissingScope=xe,e.FiefError=Je,e.FiefIdTokenInvalid=Le,e.FiefRequestError=je,e.browser=u,e.crypto=a}));
//# sourceMappingURL=index.umd.js.map
